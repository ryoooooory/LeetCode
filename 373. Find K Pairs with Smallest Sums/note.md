# 373. Find K Pairs with Smallest Sums

## step1
時間計算量: O(klogk), 空間計算量: O(k)
全探索しか思い浮かばず、ACできなかった。
回答をみて理解してその通りに実装（変数名のリネームはおこなった。）
大まかな思考の流れは以下の通り
1, 単純に全探索→ソートすると計算量がよくないので、改善のためにどのように比較をするかを考える
2, 実際に比較をするのは、最小のペア（nums1[index1], nums2[index2]）を基準に考えると、次の最小値は(nums1[index1 + 1], nums2[index2], nums1[index1], nums2[index2 + 1])かもしくは、この以前のステップでのこったもののどれかとなる。
3, 上記で以前のステップでのこったものを実現すること、常にソートされた状態でいることを考慮してHeapを使うという流れとなる。
4, あとは追加の際に重複をさけるため、Setを用意して重複のIndexペアは弾くようにする。

## step2
他の人の実装を参考に実装した。
### step2-1
参考：https://github.com/seal-azarashi/leetcode/pull/10/files
根本的な解法はstep1と同じだが、PriorityQueueにいれる中身を変えて、変数を少なくしたタイプ。変数宣言での記述量は増えるものの、繰り返しの部分は余計な合計などもなくわかりやすいかなとおもった。

### step2-2
参考：[https://github.com/seal-azarashi/leetcode/pull/10/files](https://github.com/kazukiii/leetcode/pull/11/files)
実装していて、indexまわりをまとめて独自で定義したほうが見やすいなあとおもっていて同様のコメントが上記のPRでもあったので、独自定義する方針でも実装してみた。

## メモ
Loopの表現についてfor, whileの議論が他のPRのコメントでもあったが、宣言的か手続的のどちらがいいかというものがあり、今回の問題だと個人的にはどちらでもそこまで変わらないかなと思ったが問題や条件によってはどちらが自然かというのを常に意識したい。
また問題文の制約次第ではループのなかでエラーとなる可能性があることも意識したい。
https://github.com/sakupan102/arai60-practice/pull/11#discussion_r1622031840
https://github.com/fhiyo/leetcode/pull/13/files

## step3
いただいたコメントを元に修正した。
### step3-1
アルゴリズムの修正を行なった。
・２つの配列について片方の配列のIndexしか動かさない
・動かす方のindex = 0の時のみもう片方の配列のについてその配列のIndex+1の要素をQueueに追加
することで重複がないようにおこなうことができる。

### step3-2
独自クラスの定義のし直し、および共通ロジックを関数として外出しした。
修正を行うと途端にどこが共通化されているのか、どこが無駄な処理になるのかがぼやけるので、全体の処理を頭に置きながら共通化部分をしっかり頭で描いてからコードにうつるように癖づけないといけないと思った。
また、HashSetに独自クラスのオブジェクトをいれるときに、仕組みとしてどのように一致判定を行なっているかについて気になったので以下にまとめる。

・HashSetではAbstractSetをimplementしており、equalsとhashCodeを使ってObjectの一致判定をしている。
・classは暗黙的にObjectクラスを継承しているのでequalsとhashCodeは必ずもっている。
・独自クラスでかつ一致判定をカスタムしたい時は上記をOverrideする必要がある。
