# FirstSolution

５分ほどでとけた。以前に解いたことがあり、carry がある場合の処理も忘れていなかった。

# SecondSolution

https://github.com/TORUS0818/leetcode/pull/7
を参考に再帰を使って解いた。
興味深かったのは、https://github.com/fhiyo/leetcode/pull/5/filesでスタックサイズの限界をおおよそ見積もっている点だった。
スタックが積まれる認識はもっていたが、具体的な数値を見積もってはいなかったので自分でも見積もることにした。
メモリ使用量としては、再帰の深さ D*スタックフレームサイズ M とおおよそ見積もれる。
今回のケースでは再帰の深さは 100
スタックフレームサイズは、int が 4byte、ListNode が 8byte （64 ビット JVM のとき）であると見積もると、int 変数が３つ、ListNode が３つなので、4*3+8\*3=36byte くらい？
JVM のデフォルトのスタックサイズは 1MB なので、1M/36byte=27K 回くらい再帰ができるということになる。
→ スタックフレームサイズの見積もりが正しくなく、実際は関数パラメータ、ローカル変数、リターンアドレス（呼び出し元の関数に戻るためのアドレス）、保存されたレジスタ（コンパイラとかによる）分のメモリ分となる。
なので、リターンアドレスが 8byte(64bitJVM), 保存されたレジスタが 32 バイトとすると合計で 96 バイトとなる。
したがって、1M/96byte=10K 回くらい再帰ができるということになる。
ローカルで実験してもおおよそ 10K 回くらい再帰ができることが確認でき、それ以上だとスタックオーバーフローが発生することが確認できた。

ほかに気になったものとして以下のところで番兵（sentinel）をつかっているところがあった。しかし、番兵は条件判定処理の回数を減らすために使われるものなので、今回のケースではあまり意味がないように思えたが、あまり確証はもてませんでした。
https://github.com/YukiMichishita/LeetCode/pull/2/files
→ 番兵の意味は、「境界条件におく意味の持たないデータ」くらいで使われるので、上記は正しい。

# ThirdSolution

dummy のノードを用意しないバージョンでも解いた。分岐が発生はするが、変数の役割が明確な点ではよいなと感じいい選択肢だと思った。
