# step1
自分で解いた。

# step1-1
すぐに解法が浮かんだ。
１回目の走査で文字をカウントして、２回目の走査でカウント１のもののindexを返すという考え。
時間計算量：O(n) n:文字列の長さ、空間計算量：O(n)

# step1-2
次に解法が浮かんだ。小文字英字しか使わないパターンでは配列を使ったカウントがよく使われるイメージだったのですぐ実装できた。
ただ実際の入力は英小文字以外も入ってるくる可能性があるので、条件を交渉するか１改善案くらいのイメージ。
時間計算量：O(n) n:文字列の長さ、空間計算量：O(1)
実行時間がかなりはやくなったのはboxing/unboxingのオーバーヘッドのせいかなと予想。

# step2
他の人、もしくは回答をみて参考にしたもの

# step2-1
https://github.com/seal-azarashi/leetcode/pull/15/files
を参考にした。特に入力条件としてサロゲートなどを意識できていなかったので大変勉強になった。（odaさんのコメントのこちらも：https://note.com/ttuusskk/n/n1bff5d8e638c）
マジックナンバーを使わないようにいくつか定数を設定した。

# step3  
いただいたコメントを元に修正したもの  
特に変数名について意味をもう少し具体的にして、読む人が大体正しくイメージができるくらいにすることを忘れないようにしたい。
