# First Solution

5 分ほどで AC。問題を見たときに計算量がかかりそうだと思い、順次追加処理かつソート操作に強い PriorityQueue を使うことを思いついた。実装もすぐできたので、問題なく解けた。
一部 PriorityQueue の API がわからなかったので、調べながら実装した。名前の通り基本的には Queue と同じインターフェイス

# Second Solution

https://github.com/seal-azarashi/leetcode/pull/8/files
の PR で色々な解法があったので参考にした。主に、ヒープの実装とクイックセレクトでの解放を行ってみた。

## ヒープについて

Java で PriorityQueue を使うと、デフォルトで最小ヒープになる。
ヒープ自体の特徴としては木構造で表され、各操作の計算量は以下の通り

- 要素の追加: O(log n)
- 要素の取り出し: O(log n)
- 最大値（最小値）の取得: O(1)

それぞれの操作についての概略は以下の通り

- 要素の追加: 木の先端から根に上がっていくイメージ。末尾に要素を追加し、親ノードとの大小関係を比較して、親ノードよりも小さい（大きい）場合は親ノードと入れ替える。これを根ノードまで繰り返す。
- 要素の取り出し: 根ノードを取り出し、末尾の要素を根ノードに移動する。その後、根ノードから子ノードとの大小関係を比較して、子ノードの方が大きい（小さい）場合は子ノードと入れ替える。これを末端まで繰り返す。
- 最大値（最小値）の取得: 根ノードに最大値（最小値）が格納されているので、根ノードを取り出すだけで良い。

## クイックセレクトについて

クイックセレクトについては以下のサイトを参考にした。
https://www.youtube.com/watch?v=zgQNdpxJGMw

クイックセレクトの計算量は平均だと O(n),これは T(n) = O(n) + O(n/2) + O(n/4) + ... という再帰式を解くと無限等比級数の和により O(n) になるため。
最悪計算量については、ピポットを運悪く選んで、毎回１つの要素しか分けられないと、T(n) = O(n) + O(n-1) + O(n-2) + ...という再帰式を解くと O(n^2) になる。

ステップは以下の通り

- ピボットを選択する: ランダムに選んだり、
- ピボットを基準にして、左右に分割する
- K が左側の要素数よりも大きい場合は右側を探索する、逆の場合は左側を探索する
  今回はソートの向きが逆なので注意
