# step1
10分AC。時間計算量：O(nlogk), 空間計算量: O(n)
自分で解いた。解法自体はすぐに浮かんだが、標準ライブラリのソートの書き方がままならず調べながら実装した。
PriorityQueueを使った場合では、kこの要素以上はいらないので分岐処理できることに最適化に途中で気付いたので、最初から気付けるようにしたい。
解く時のイメージは以下の通り。
1, まず要素ごとのカウントが必要
2, そのあと、要素と出現数についてソートをする必要がある。
1は問題ないが、2についてはソートもしくは、PriorityQueueを使って追加しながら自動でソートしていく方法が思いついた。
処理を最適化しないと、ソートした時もPriorityQueueを使うときもO(nlogn)だが、PriorityQueueの大きさをkで抑えることで、O(nlogk)

# step2
他の人の回答もみて、変数名を変更した。
https://github.com/kazukiii/leetcode/pull/10/files

# step3
他の人のレビューをみてみると関連知識としてQuickSelectの解法もあったので、勉強のためにそちらでも解いてみた。
https://github.com/Ryotaro25/leetcode_first60/pull/10#discussion_r1627890286
以前他の問題でもQuickSelectをやっていたがまだ身に付いてはいなかったので実装に15分ほど時間がかかってしまった。
K番目までみたいにわかりやすい条件のときは、すぐに知識がリンクするようにしたい。

# Step4
## 4-1
Step3での指摘を受けてMap.Entryを使わずにクラスを定義したもの

## 4-2
Step4-1での指摘を受けてソートを逆順して、配列にいれるときのIndex順を自然なものにしたもの

## 4-3
Step1での指摘を受けて、for分で配列に値を入れてく代わりにiteratorを使ったもの、コメントにあるとおりkの考慮などが減るので選択肢としてもっておきたい。また、変数がふえることについては（int index）Listにまずは値をいれるようにしてreturnのところで配列に変換する手もあるなとおもった。（あまりにもkが大きい時はしないほうがいいが）
