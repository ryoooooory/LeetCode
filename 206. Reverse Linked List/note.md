# First Solution

Time: O(n), Space: O(1), n は LinkedList の長さ
自分で AC した回答。時間的には 10 分で計算量も考えられたが、もう少し早く解けるようになりたい。
解法は 1 つ目、2 つ目両方すぐ思いついた。1 つ目の方が空間計算量が少ないので、それを選択した。
1 つ目について思考は、現在と次の Node の関係性を更新すると同時に次の Node も保持する必要があるので、３つの変数を用意して、prev, current, next が１セットで更新していくようなイメージで処理を実装した。
見直すと、そもそも next は current の更新のタイミングしか使っておらず、ループの最初で更新するだけでいいことに気づいたので、prev, current だけで十分として処理を書き直した。
2 つ目については、シンプルに逆順ということで Stack が思い浮かんだので、Stack につんでから上から順に取り出していくという方法をとった。

# Second Solution

https://github.com/seal-azarashi/leetcode/pull/7/files
をみていたところ再帰処理での実装があることに気づいたので、再帰処理での実装を試みた。
思考としては、再帰を各段階での単発作業として考えて、作業内容は現在の Node の Head（current）と、連結用のもの（prev）が渡されるので、それを逆順にしていく、次の作業の引き継ぎのために Head（current）を保持するというイメージで処理を書いた。
別解の方はhttps://discord.com/channels/1084280443945353267/1231966485610758196/1239417493211320382を参考に、先頭を再帰先からもらい現在のNodeについて逆順に繋ぎかえていくものだが、よくよく考えると自分の上記の再帰での解法と考え方の差は先に現在のNodeで逆順繋ぎを全部してから次のNodeについて再帰先でやるか、次のNodeで作業を完了させてからそれをもらってこちらの作業でつづきをやるかの違い。
再帰は端での処理と、各階層での処理をしっかりイメージできるかが重要だと感じた。
