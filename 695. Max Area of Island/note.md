# solution1

問題を見て自力でまず解いた。
問題を見た瞬間に BFS、DFS を思いついたが、DFS だとスタックの問題があるのでなんとなく BFS のがいいかと思い BFS で解いたが、理由などは明確にしたい。
位置（row, col）について Pair を使うか悩んだが以前違う問題でコメントいただいたところもあり独自のクラスを作成した。
時間は 15 分ほどで少し BFS の実装に手間取ったので慣れていきたい。
時間計算量 O(n*m)、空間計算量 O(n*m) n,m:グリッドのサイズ

# solution2_1

他の人の解法や公式の解法を参考にリファクタリング。
BFS の部分がネストが深いこともあり関数分離した。
・（https://github.com/colorbox/leetcode/pull/32/files）
コメントにある delta を二次元配列で行う方法はいいなと思ったので採用
海を表す値 0 についても確かにマジックナンバーだなと思ったので、こちらも定数で宣言するようにした。

# solution2_2

DFS で解いた。
時間計算量 O(n*m)、空間計算量 O(n*m) n,m:グリッドのサイズ
これは他の人の回答をみていた感想だが、入力値の配列を変更してもいいか疑問におもった（今回の問題みたいに特定の情報をカウントみたいなケースだと基本的に元のデータはいじらないことの方が多いのではないかと思った。読み取りと更新両方をするケースでも、その場合は処理フローを分けたほうがいいのかなと思った。）

# 学んだこと

・https://github.com/goto-untrapped/Arai60/pull/31
DFS の場合空間計算量で、50 \* 50 なのはわかっていたが、スタックメモリを考慮してどれくらい呼べるかを考えているのがとてもいいなと思った。
変数（引数も）: （ex int=4byte,long=8byte,char=2byte)
戻り値:　 64bitCPU なら 8byte?
ということで、引数やもろもろ合わせてスタックフレームを 100 バイトくらいとすると、1MB / 100 = 10000 回くらいは呼び出せる。

リターンアドレス：関数内で次の関数を呼び出した時のスタックポインタ（呼び出し先の処理完了後に戻れるように）
ベースポインタ：関数内で次の関数を呼び出した時の一番上のアドレス（ローカル変数や引数の参照のため）

コメントを元に定数は基本 static にしようと思った。
https://google.github.io/styleguide/javaguide.html#s5.2.4-constant-names
