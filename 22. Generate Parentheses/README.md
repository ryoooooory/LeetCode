# 1 回目

アプローチとしては（）を再帰的に適切な位置に挿入していき、最終的な長さになったら HashSet に加えていくというもの（重複を防ぐために Set を使っています）。
適切な位置というのは、挿入した"（"に対して、"（"の位置より右側で"）"が挿入されることをいみしています。(これで正しい文字列であることは保証されるので)
途中でメモ化していないことによる TLE になったので、途中の文字列についても保持して重複した再帰処理を防ぐようにしました・

# 2 回目

コメントいただいた方法で修正しました。
アプローチとしては、末尾に"(",")"を挿入して Queue に保存していき、最終的に文字列の長さが 2 _ n になったら、正しい文字列かどうかを確認して正しければ List に加えるというものです。
途中で正しい文字列か（")"のが多くならないか）をチェックしています。こちらについては最後だけ正しい文字列かをチェックする方法もあり、処理のシンプルさでは最後だけチェックのがよいですが、速度的に n が大きくなればなるほど最終的にチェックする数が増えると思うので、途中で判定して Queue に追加するものを選択したほうがはやくなると思っています。
時間計算量がわかりやすくて、文字列の長さ分毎回２倍増えていきますので、2^(2n)かかり、あと正しいかの判定に 2n かかるので、O(2^(2n) _ n)となるかと思います。
空間計算量についても、Queue に入る最大の要素数は 2^(2n - 1), 要素となる文字列の長さは最大 2n なので O(2^(2n) \* n)となるかとおもいます。
