# firstSolution

アプローチとしては（）を再帰的に適切な位置に挿入していき、最終的な長さになったら HashSet に加えていくというもの（重複を防ぐために Set を使っています）。
適切な位置というのは、挿入した"（"に対して、"（"の位置より右側で"）"が挿入されることをいみしています。(これで正しい文字列であることは保証されるので)
途中でメモ化していないことによる TLE になったので、途中の文字列についても保持して重複した再帰処理を防ぐようにしました・

# refactoredByMyselfSolution

# refactoredSolution

0, 変数名修正
コメントいただいた箇所について修正しました。
状態についても必要十分で変数名に含めてあげる意識が足りないなと思いました。

1, Queue を使った loop
コメントいただいた方法を元に以下のように考えました。
アプローチとしては、末尾に"(",")"を挿入して Queue に保存していき、最終的に文字列の長さが 2 _ n になったら、正しい文字列かどうかを確認して正しければ List に加えるというものです。
途中で正しい文字列か（")"のが多くならないか）をチェックしています。こちらについては最後だけ正しい文字列かをチェックする方法もあり、処理のシンプルさでは最後だけチェックのがよいですが、速度的に n が大きくなればなるほど最終的にチェックする数が増えると思うので、途中で判定して Queue に追加するものを選択したほうがはやくなると思っています。
途中でコメントもいただき、左の数を文字列に対して保持しておけば、毎回チェックの処理を O(n)で走らせないですむので、新規に（の数を保持しておく Queue を作りました。
時間計算量がわかりやすくて、文字列の長さ分毎回２倍増えていきますので、2^(2n)かかり、あと正しいかの判定に 2n かかるので、O(2^(2n) _ n)となるかと思います。
空間計算量についても、Queue に入る最大の要素数は 2^(2n - 1), 要素となる文字列の長さは最大 2n なので O(2^(2n) \* n)となるかとおもいます。

追加いただいたコメントで、Queue は１つにまとました（管理の面でも、複数管理の場合は更新し忘れなどのリスクもあるのでまとめて管理したほうが合理的だと思いました。）
文字列と開いた（の数をまとめたクラスの命名については少し不安です（State とか Info とかしか浮かびませんでした）。

2, 再帰を使った方法
再帰については、基本的に上記と考え方が同じなので、すんなり実装はできました。コメントいただいた通り、途中で条件をしっかり確認すればかなり不要な文字列のチェックを抑えることができるので、しっかり実装前や途中で不要なパターンをしっかり明確化できるのかが大事だと改めて感じました。
また String の add に文字数分のコストがかかることを教えていただき、かなり処理時間に差が出るので StringBuilder を使ったアプローチを常に考えようと思いました。
[確認した他の実装](https://github.com/hayashi-ay/leetcode/pull/70)

3, Queue を使った loop の別アプローチ
複数のアプローチを思い浮かべられるとよい＋ループの考えについて教えていただいたので、それをベースに違うアプローチで（）を挿入した。
挿入については"(" + ")"\*n n:0 <= n <= 閉じてない（の個数　として挿入をしていく
挿入したものは被りはない
挿入中に n = 4 で((((((((( みたいにケースでは閉じる括弧を加えると溢れてしまうケースがありえるので、それを途中で阻止するようにした。
