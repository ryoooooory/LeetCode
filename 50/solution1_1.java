/*
・概要
自力解法。5分くらいでできた。案の定StackOverFlow

・解き方
累乗部分を-1しながらするのが一番シンプルだなと思いそのまま実装してみた。
問題制約により、nが2^30 ≈ 10^9くらいなので当然StackOverFlow

メモリ使用量としては、再帰の深さ D*スタックフレームサイズ M とおおよそ見積もれる。
スタックフレームサイズは、double が 8byte, int が 4byte （64 ビット JVM のとき）であると見積もると、
JVM のデフォルトのスタックサイズは 1MB なので、1M/36byte=27K 回くらい再帰ができるということになる。
→ スタックフレームサイズの見積もりが正しくなく、実際は関数パラメータ、ローカル変数、リターンアドレス（呼び出し元の関数に戻るためのアドレス）、保存されたレジスタ（コンパイラとかによる）分のメモリ分となる。
なので、リターンアドレスが 8byte(64bitJVM), 保存されたレジスタが 32 バイトとすると全部で大体50byteくらい
したがって、1M/50=20K 回くらい再帰ができるということになる。
ローカルで実験してもおおよそ 10K 回くらい再帰ができることが確認でき、それ以上だとスタックオーバーフローが発生することが確認できた。(なぜかleetCodeのコンソールでが100万回くらいはできるが、これは多分leetCodeの設定のせい)


・計算量
時間：O(n)
空間:O(n)
*/

public class solution1 {
  public double myPow(double x, int n) {
    if (n == 0) {
      return 1;
    }
    if (n > 0) {
      return x * myPow(x, n - 1);
    } else {
      return (1 / x) * myPow(x, n + 1);
    }
  }
}
